\renewcommand{\chaptermark}[1]{\markboth{Appendix \thechapter\relax:\thinspace\relax#1}{}}
\chapter{Binary representation of FFS images and Classes}
\label{app:binary_rep}
This appendix visualizes the binary structures produced when serializing the \texttt{InodeTable}, the \texttt{InodeEntry}, and the \texttt{Directory} objects, and the binary structure of the encoded FFS images. The models are in terms of bytes, index $0$ indicating the first byte, index $1$ indicating the second byte, etc.

\section{Serialized C++ objects}
The \texttt{InodeTable}, \texttt{InodeEntry}, and the \texttt{Directory} class all have one \texttt{serialize} and one \texttt{deserialize} method each. The \texttt{serialize} method converts the objects data into binary form, and the \texttt{deserialize} method converts the serialized data into an object. The deserializer expects the same format of its input data as the serializer produces. The figures in this section visualizes the serialized output of the different classes. Figure~\ref{fig:app_bin_table} visualizes the serialized format of the \texttt{InodeTable}. Figure~\ref{fig:app_bin_entry} visualizes the serialized format of the \texttt{InodeEntry}. Figure~\ref{fig:app_bin_dir} visualizes the serialized format of the \texttt{Directory}. 
	
\begin{figure}[!htb]
	\label{fig:app_bin_table}
	\centering
    \textbf{\texttt{InodeTable}}\par\medskip

	% bitwidth = 1/16 * textwidth
	\begin{bytefield}[bitwidth=0.0625\textwidth]{16}
		\bitheader{0,3} \\
		\bitbox{4}{\#~Inode Entries}\\
		\bitheader[lsb=4]{4,7} \\
		\bitbox{4}{Inode~1} & \bitbox{12}{Inode Entry~1} \\
		\bitbox{4}{Inode~2} & \bitbox{12}{Inode Entry~2} \\
		\wordbox[]{1}{$\vdots$} \\[1ex]
		\bitbox{4}{Inode~N} & \bitbox{12}{Inode Entry~N} \\
	\end{bytefield}
	\caption[Byte representation of the serialization of a \texttt{InodeTable} object]{\texttt{\#~Inode Entries} is an unsigned integer representing the amount of inode entries the inode table contains. Following are \texttt{\#~Inode Entries} entries of an unsigned integer representing the inode of the inode entry, and the serialization of the corresponding \texttt{InodeEntry} object}
\end{figure}

\begin{figure}[!htb]
	\label{fig:app_bin_entry}
	\centering
    \textbf{\texttt{InodeEntry}}\par\medskip

	% bitwidth = 1/17 * textwidth
	\begin{bytefield}[bitwidth=0.05882\textwidth]{17}
		\bitheader{0,3,4,5,12,13,16} \\
		\bitbox{4}{length} & \bitbox{1}{$is_d$} & \bitbox{8}{$t_{created}$} & \bitbox{4}{$t_{accessed}$} \\ [1ex]
		\bitheader[lsb=17]{17,20,21,28,29,32} \\
		\bitbox{4}{$t_{accessed}$} & \bitbox{8}{$t_{modified}$} &\bitbox{4}{\#~Posts}\\
		\bitbox{13}{Post~1}\\
		\bitbox{13}{Post~2}\\
		\bitbox[]{15}{$\vdots$} \\[1ex]
		\bitbox{13}{Post~N}
	\end{bytefield}
	\caption[Byte representation of the serialization of an \texttt{InodeEntry} object]{Byte representation of a serialized \texttt{InodeEntry}, representing a file or directory stored in FFS. \texttt{length} is an unsigned integer representing the amount of data stored on FFS by the file or directory, for instance the size of the file. \texttt{$is_d$} is a boolean with the value true ($\neq{0}$) if the inode entry represents a directory, and false ($= 0$) if the inode entry represents a file. $t_{created}$, $t_{accessed}$, and $t_{modified}$ are unsigned integers represents timestamps of when the file or directory was created, last accessed and last modified, respectively. \texttt{\#~Posts} is an unsigned integer representing the amount of posts the file or directory is stored in on the OWS. Following are \texttt{\#~Posts} null-terminated strings representing each post ID in the OWS. The size of this field depends on the OWS used, for instance does Flickr often generate 11-byte post IDs. However, as the strings are null-terminated, the deserializer can read the bytes until the null-character is found}
\end{figure}


\begin{figure}[!htb]
	\label{fig:app_bin_dir}
	\centering
    \textbf{\texttt{Directory}}\par\medskip

	% bitwidth = 1/16 * textwidth
	\begin{bytefield}[bitwidth=0.0625\textwidth]{16}
		\bitheader{0,3} \\
		\bitbox{4}{\#~Entries} \\
		\bitheader[lsb=4]{4,7} \\
		\bitbox{4}{Inode~1} & \bitbox{12}{Filename~1}\\
		\bitbox{4}{Inode~2} & \bitbox{12}{Filename~2}\\
		\wordbox[]{1}{$\vdots$} \\[1ex]
		\bitbox{4}{Inode~3} & \bitbox{12}{Filename~3}\\
	\end{bytefield}
	\caption[Byte representation of the serialization of an \texttt{Directory} object]{Byte representation of a serialized \texttt{Directory}. \texttt{\#~Entries} is an unsigned integer representing the amount of entries in the directory. Following are \texttt{\#~Entries} inode-filename pairs. The \texttt{Inode} is an integer representing the inode of the file or directory, corresponding to the file's or directory's entry in the inode table. The filename is a null-terminated strings representing the filename of the file or directory in FFS. The size of this field can vary from filename to filename. However, as the strings are null-terminated, the deserializer can read the bytes until the null-character is found}
\end{figure}

\section{FFS Images}
An FFS images consists of multiple binary structures, including the FFS header and the encrypted data. This section visualizes these binary structures. Figure~\ref{fig:app_bin_ffs_header} visualizes binary format of the FFS header. Figure~\ref{fig:app_bin_pixels} visualizes the pixel color data of FFS images stored on the OWS.

\begin{figure}[!htb]
	\label{fig:app_bin_ffs_header}
	\centering
    \textbf{FFS Header}\par\medskip

	% bitwidth = 1/16 * textwidth
	\begin{bytefield}[bitwidth=0.0625\textwidth]{16}
		\bitheader{0,1,2,3,4,11,12,15} \\
		\bitbox{1}{'F'} & \bitbox{1}{'F'} & \bitbox{1}{'S'} &
		\bitbox{1}{V} & \bitbox{8}{Timestamp} & \bitbox{4}{Data length}
		
	\end{bytefield}
	\caption[Byte representation of the FFS image header]{\texttt{'F'} and \texttt{'S'} are the literal letters F and S in ASCII code. \texttt{V} is an integer representing the version of the FFS image produced. \texttt{Timestamp} is an unsigned integer representing the number of milliseconds since Unix epoch when the image was encoded. \texttt{Data length} is an unsigned integer representing the number of bytes stored after the header. Following the heder is \texttt{Data length} bytes, containing the actual data stored in the image.}
\end{figure}

\begin{figure}[!htb]
	\label{fig:app_bin_pixels}
	\centering
    \textbf{Pixel color data in FFS images}\par\medskip

	% bitwidth = 1/32 * textwidth
	\begin{bytefield}[bitwidth=0.0312\textwidth]{32}
		\bitheader{0,3} \\
		\bitbox{4}{LCED}
		\begin{rightwordgroup}{CED}\\
			\bitheader[lsb=4]{4,35} \\
			\wordbox[lrt]{1}{} \\
			\wordbox[lrb]{1}{Salt} \\
			\bitbox{12}{initialization Vector (IV)} & \bitbox[ltr]{20}{}\\
			\wordbox[lr]{1}{} \\
			\wordbox[lr]{1}{Encrypted cipher text} \\
			\skippedwords \\
			\wordbox[lr]{1}{} \\
			\bitbox[lb]{16}{} & \bitbox{16}{Authentication Tag}
		\end{rightwordgroup} \\
		\wordbox[lr]{1}{} \\
		\wordbox[lr]{1}{Filler bytes} \\
		\skippedwords \\
		\wordbox[blr]{1}{} \\
	\end{bytefield}
	\caption[Byte representation of the data stored as pixel color data in FFS images]{Byte representation of the data stored as pixel color data in FFS images. \texttt{LCED} an unsigned integer representing the Length of the Complete Encrypted Data (\gls{CED}). The \texttt{Salt} is a 64-byte randomized vector used to derive the encryption and decryption key. The \texttt{IV} is a 12-byte randomized vector used as the initial state of the encryption and decryption methods. Following is the \texttt{Encrypted cipher text} of variable size, depending on the size of the unencrypted data. The FFS header and the data to be stored, for instance the data of a file, is what is encrypted to become the \texttt{Encrypted cipher text}. The \texttt{Authentication Tag} is a 16-byte vector produced by the authenticated encryption method, and verified by the decryption method, to ensure data integrity has been upheld. Following is a number of filler bytes, depending on the size of the preceding data, to ensure the image has enough number of pixels for its calculated dimensions.}
\end{figure}