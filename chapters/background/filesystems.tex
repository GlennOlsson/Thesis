\section{Filesystems and data storage}
This section presents how certain filesystems used today are structured. We present the idea of inode-based filesystems and distributed filesystems. Following, we describe how data is stored in a storage system and how this information can be used in FFS.

\subsection{Unix filesystems}
A Unix filesystem uses a data structure called an \textit{inode}. The inodes are found in an inode table and each inode keeps track of the size, blocks used for the file's data, and metadata for the files in the filesystem. A directory simply contains the file names and each file or directory's inode id. The system can with an inode id find information about the file or directory using the inode table. Each inode can contain any metadata that might be relevant for the system, such as creation time and last update time. 

Figure~\ref{fig:inode_diag} shows how example inode filesystem and how it can be visualized. The blocks of an inode entry are where in the storage device the data is stored, each block is often defined as a certain amount of bytes. Listing~\ref{lst:inode_fs} describes a simple implementation of an inode, an inode table, and directory entries. 

% TODO: Add info about how FFS will only implement some metadata? And/or add that to delimitations too

\begin{figure}[!ht]
	\begin{center}
	  \includegraphics[width=0.5\textwidth]{figures/inode_diagram.png}
	\end{center}
	\caption{Basic structure of inode-based filesystem}
	\label{fig:inode_diag}
\end{figure}

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=c, caption={Pseudocode of a minimalistic inode filesystem structure}, label=lst:inode_fs]
struct inode_entry {
	int 	length
	int[]	blocks
	// Metadata attributes are defined here
}

struct directory_entry {
	char*   filename
	int     inode
}

// Maps inode_id to a inode_entry
map<int, inode_entry> inode_table

\end{lstlisting}
\end{minipage}

Different filesystems provide different features and limitations. Extended Filesystem (ext) exists in four different versions: ext, ext2, ext3, and ext4. This filesystem is often used on Unix systems. Each iteration brings new features and changes the limitations. For instance, comparing the two latest iterations, ext3 and ext4, ext4 can theoretically store files up to \SI{16}{\tebi\byte} while ext3 can store files up to \SI{2}{\tebi\byte}\,\cite{salterUnderstandingLinuxFilesystems2018}. Additionally, ext4 supports timestamps in units of nanoseconds while et3 only supports timestamp with resolution of one second. The Zettabyte filesystem (ZFS) introduces features that no version of ext supports, such as block-level cryptographic checksumming\,\cite{salterUnderstandingLinuxFilesystems2018}.
% FIXME: Why is only ZFS mentioned? Mention more? Motivate why? IDK

% TODO: Chip: "I would suggest a table of file system operations by different file systems and which one you choose to implement in FFS. Think about tables such as https://nuetzlich.net/gocryptfs/comparison/ to summarize information about alternatives."
% 	Do here as it is apparently part of the pre-study, or in summary section


\subsection{Distributed filesystems}
Filesystems are used to store data on for instance a hard drive of a computer locally or in the cloud. For example, Google Drive is a filesystem that enables users to save their data online with up to \SI{15}{\giga\byte} for free\,\cite{CloudStorageWork} using Google's clusters of distributed storage devices, meaning that the data is saved on Google's servers which can be located wherever they have data centers\,\cite{DistributedStorageWhat}. Paying customers can have a greater amount of storage using the service. Apple's iCloud and Microsoft's OneDrive are two additional examples of distributed filesystems where users have the option of free-tier and paid-tier storage.

\subsection{Data storage and encoding}
Different file types have different protocols and definitions of how they should be encoded and decoded, for instance a JPEG and a PNG file can be used to display similar content but the data they store is different. At the lowest level, storage devices often represent files as a string of binary digits no matter the file type (however there are non-binary storage devices\,\cite{MultistateDataStorage2020}, but this is outside the scope of this thesis). If one would represent an arbitrary file of $X$ bytes, each byte (0x00 - 0xFF) can be represented as a character such as the Extended ASCII (EASCII) keyset and we can therefore decode this file as $X$ different characters. Using the same set of characters for encoding and decoding we can get a symmetric relation for representing a file as a string of characters. EASCII is only one example of such a set of characters, any set of strings with $256$ unique symbols can be used to create such a symmetric relation, for instance, $256$ different emojis or a list of $256$ different words. However, if we are using a set of words we could also have to introduce a unique separator so that the words can be distinguished. If we would use a single space character as the separator, we could make the encoded text look like a text document; however, with random words one after another leading to a high probability of creating an unstructured text document. Further, if punctuation is introduced, for instance as part of some words, the text document could look like it contains random and unstructured sentences.

% FIXME: Chip: "There is a citation example shown on the page: ARC Centre of Excellence in Future Low-Energy Electronics Technologies. "Multi-state data storage leaving binary behind: Stepping 'beyond binary' to store data in more than just 0s and 1s." ScienceDaily. ScienceDaily, 12 October 2020. <www.sciencedaily.com/releases/2020/10/201012115937.htm>.More over, you could actually cite the journal paper: Qiang Cao, Weiming LÃ¼, X. Renshaw Wang, Xinwei Guan, Lan Wang, Shishen Yan, Tom Wu, Xiaolin Wang. Nonvolatile Multistates Memories for High- Density Data Storage. ACS Applied Materials & Interfaces, 2020; 12 (38): 42449 DOI: 10.1021/acsami.0c10184"

This string of $X$ bytes can also be used as the data in an image. An image can be abstracted as a $h * w$ matrix, where each element is a pixel of a certain color. In an image with 8-bit Red-Green-Blue (RGB) color depth, each pixel consists of three 8-bit values, i.e. three bytes. One can therefore imagine that we can use this string of $X$ bytes to assign colors in this pixel matrix by assigning the first three bytes as the first pixel's color, the next three bytes as the following pixel's color, and so forth. This means that $X$ bytes of data can be represented as 
$$ceil(\frac{X}{3})$$ 
pixels, where $ceil$ rounds a float to the closest larger integer. For a file of \SI{1}{\mega\byte}, i.e. $X = 1\,000\,000$ we need $333\,334$ pixels in an image with 8-bit RGB color depth. The values of $h$ and $w$ are arbitrary but if we for instance want a square image we can set $ h\,=\,w\,=\,578$ which means that there will be $334\,084$ pixels in total, and the remaining $750$ pixels will just be fillers to make the image a reasonable size. Using filler pixels requires us to keep track of the number of bytes that we store in the image so that we do not read the filler bytes when the image is decoded. However, we could choose $h = 1$ and $w = 333\,334$ which would mean a very wide image but would not require filler pixels. 

This means that we can represent any file as a string of bytes which can then be encoded into text or as an image, which can be posted on for instance social media. However, there is a possibility that the social media services compress the images uploaded which could lead to data loss in the image, which would mean that the decoded data would be different from the encoded data. In this case we would not be able to retrieve the original data that was stored.