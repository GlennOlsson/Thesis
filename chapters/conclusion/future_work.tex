
\section{Future work}
\label{sec:futureWork}
As mentioned previously, \gls{FFS} does not implement all of the features that the POSIX standard defines. Future development for \gls{FFS} could be to implement more of these functions, such as links and file permissions. This could make \gls{FFS} further resemble a regular filesystem. Another improvement could be to move from userspace using \gls{FUSE}, to kernel space. This could speed up filesystem operations. Another feature that could be interesting to evaluate is the possibility to share files with other users, similar to Google Drive.

Although the files are encrypted so that the data is confidential, further research could include hiding the user's online activity through the use of a distributed service to anonymize traffic origins, for instance, Tor. Currently, the anonymity of the user is not considered but for \gls{FFS} to further increase plausibly deniable, this should be addressed as the user could otherwise be identified by based upon their IP address and other online fingerprints that could be provided by the \glspl{OWS} and \glspl{ISP}.

The deniability of the data stored on \gls{FFS} could be compromised if there are any lingering information about the filesystem available on the computer or in the operating system after the filesystem has been unmounted. For instance, if \gls{FUSE} would create temporary files in the underlying filesystem with information about mounted filesystems, including write and read counts, and this information is not cleaned when the filesystem is unmounted, it could be possible for an adversary to discover otherwise secret information about the users usage of \gls{FFS}. During research for this thesis, no such information was found, but thorough analysis of the computer and operating system was not conducted. Future research includes analyzing if \gls{FFS} leaves any lingering information on the computer that could reveal the use of the filesystem.

To improve the dependability and increase the storage capacity of \gls{FFS}, support for multiple \glspl{OWS} could be implemented. For instance, GitHub provides free user accounts with many gigabytes of storage. Even \mbox{free-tier} distributed filesystems, such as Google Drive, could be utilized. If multiple user accounts are used in coordination over multiple \glspl{OWS}, \gls{FFS} could achieve even more storage. Future work includes comparing such a filesystem with the current state of \gls{FFS}.

To further increase the storage capacity, \gls{FFS} could take advantage of storing videos on the \gls{OWS} as well. Flickr allows videos up to \SI[per-mode = symbol]{1}{\giga\byte} on its service. Future work could include researching how much steganographic data can be stored in videos and how efficient a filesystem using encoded videos could be.

If the \gls{OWS} would pursue identifying \gls{FFS} images stored on their service to remove them, this would be a problem for \gls{FFS}. Even removing a single image could remove the full functionality of the filesystem. Future work should include finding evasion techniques to hide the encoded data even further. For instance, hiding less data per image is a possibility that could enable the images to look like actual images, such as photographs. This is similar to the idea of CovertFS\,\cite{baliga2007web} where a maximum of \SI[per-mode = symbol]{4}{\kilo\byte} per image would be used. However, this would significantly decrease the storage capacity of \gls{FFS}. Part of future work is to explore if more data could be stored in the images, or if multiple \glspl{OWS} could be used to overcome the decreased storage capacity. 

\gls{GCSF} outperforms \gls{FFS} in most aspects, and it is interesting to see how \gls{GCSF} would perform when implementing client side encryption. Client side encryption can easily be enabled for Google Workspace organization accounts, but for personal accounts, the Google cryptographic software development kit could be used instead.

% TODO: To get bandwidth of each filesystem: 
%	Record all requests
%	When filtering, look at all DNS requests to google.com/flickr.com
%	Only look at packets to/from these IPs
%	Need a lot of memory/save the file multiple to record all packets
%	Also takes a lot of time to filter all packets, millions if not billions
%
%