\section{Benchmarking}
This section describes the methodology and execution of the different filesystem benchmarks. Two different filesystems that are relevant to \gls{FFS}: (1) \gls{APFS} and (2) \gls{GCSF}, are compared with the result of two different instances of \gls{FFS}: (1) one instance that uses Flickr as its \gls{OWS}, and (2) one instance that uses a \gls{FOWS} by storing the encoded images in the local filesystem on the test machine. 

\subsection{Filesystems}
To analyze the performance of \gls{FFS}, a filesystem benchmarking tool is used to compare \gls{FFS} against other filesystems that are relevant to \gls{FFS}. The filesystems \gls{FFS} is compared to are:
\begin{enumerate}
	\item An encrypted \gls{APFS} partition on an SSD,
	\item An instance of \gls{GCSF}, and,
	\item An instance of \gls{FFFS} using an encrypted \gls{APFS} filesystem on an SSD as its \gls{FOWS}.
\end{enumerate}
The encrypted \gls{APFS} filesystem was used as a reference for a local filesystem without the required internet connection. It is the local filesystem of the development environment for \gls{FFS}. It was selected as it will give the analysis an example of a modern, \mbox{well-used}, and fast filesystem, and how the benchmark data of \gls{FFS} and other filesystems compare to this local filesystem.

\gls{GCSF} was selected to compare \gls{FFS} against another \mbox{network-based} filesystem. While \gls{GCSF} is not a steganographic filesystem, it is a filesystem that stores its data on an \gls{OWS}, namely Google Drive. The reason \gls{GCSF} was used instead of, for instance, the official Google Drive mountable filesystem volume provided by the Google Drive Desktop application, is that \gls{GCSF} provides instant upload of the files and directories to Google Drive using the Google Drive REST \gls{API}. The instant upload provided by \gls{GCSF} enables us to easily measure the duration of a file operation. For instance, a write operation on a file in \gls{GCSF} will not complete before the new file data has been completely stored on Google Drive. Another reason why \gls{GCSF} was chosen was because it is a recent filesystem compared to other related filesystems. Some of the other filesystems discussed in Section~\ref{sec:rel_fs} were developed many years before \gls{FFS} and thus no longer work as expected, for instance, due to changes in the \gls{API}, or because the \gls{OWS} manages the uploaded data differently than previously.

The instance of \gls{FFFS} using a \gls{FOWS} of an encrypted \gls{APFS} was chosen to be compared to \gls{FFS} so that the duration of the \gls{FUSE} filesystem operations could be further analyzed. As the filesystem operations of \gls{FFFS} are similar to the ones of \gls{FFS}, other than the network request being replaced by local filesystem operations, it is possible to analyze the effect of the \gls{OWS} latency, the \gls{OWS} internet connection bandwidth and latency, and the \gls{OWS} data processing speed has on the filesystem performance. Comparing the benchmark results of \gls{FFFS} and \gls{APFS} allows us to analyze the \gls{FFS} overhead as \gls{FFFS} is dependent on the performance of \gls{APFS}. Especially for file operations where \gls{FFFS} must interact with the storage medium, for instance, write operations and read operations for files not in the cache, \gls{FFFS} cannot outperform \gls{APFS} as it will require the execution time of the \gls{APFS} file operation as well as the internal \gls{FFS} computation time.

\subsection{Tools}
IOZone\,\cite{IozoneFilesystemBenchmark} is a filesystem benchmarking tool used to analyze the performance of filesystem file operations using different tests on a file\,\cite{iozoneIozoneFilesystemBenchmark}. Examples of tests that IOZone provides support for are: reading and writing, reading and writing randomly, and reading backward. Each test can be run with different file sizes and different buffer sizes used for the read- or write operation. Normally, multiple buffer sizes are used for each test, for each file size tested. The buffer size starts at \SI{4}{\kilo\byte} and increases by a multiple of two up to a buffer size equal to the file size. Multiple file sizes are often used for benchmarking tests as well. For instance, one could run the IOZone tests with file size \SI{1024}{\kilo\byte} and \SI{2048}{\kilo\byte}, which would utilize the following values of the file size and buffer size for each test specified:
\needspace{18\baselineskip}
\begin{enumerate}
	\item File size = \SI{1024}{\kilo\byte}, buffer size = \SI{4}{\kilo\byte},
	\item File size = \SI{1024}{\kilo\byte}, buffer size = \SI{8}{\kilo\byte},
	\item File size = \SI{1024}{\kilo\byte}, buffer size = \SI{16}{\kilo\byte},
	\item File size = \SI{1024}{\kilo\byte}, buffer size = \SI{32}{\kilo\byte},
	\item File size = \SI{1024}{\kilo\byte}, buffer size = \SI{64}{\kilo\byte},
	\item File size = \SI{1024}{\kilo\byte}, buffer size = \SI{128}{\kilo\byte},
	\item File size = \SI{1024}{\kilo\byte}, buffer size = \SI{256}{\kilo\byte},
	\item File size = \SI{1024}{\kilo\byte}, buffer size = \SI{512}{\kilo\byte},
	\item File size = \SI{1024}{\kilo\byte}, buffer size = \SI{1024}{\kilo\byte},
	\item File size = \SI{2048}{\kilo\byte}, buffer size = \SI{4}{\kilo\byte},
	\item File size = \SI{2048}{\kilo\byte}, buffer size = \SI{8}{\kilo\byte},
	\item File size = \SI{2048}{\kilo\byte}, buffer size = \SI{16}{\kilo\byte},
	\item File size = \SI{2048}{\kilo\byte}, buffer size = \SI{32}{\kilo\byte},
	\item File size = \SI{2048}{\kilo\byte}, buffer size = \SI{64}{\kilo\byte},
	\item File size = \SI{2048}{\kilo\byte}, buffer size = \SI{128}{\kilo\byte},
	\item File size = \SI{2048}{\kilo\byte}, buffer size = \SI{256}{\kilo\byte},
	\item File size = \SI{2048}{\kilo\byte}, buffer size = \SI{512}{\kilo\byte},
	\item File size = \SI{2048}{\kilo\byte}, buffer size = \SI{1024}{\kilo\byte}, and
	\item File size = \SI{2048}{\kilo\byte}, buffer size = \SI{2048}{\kilo\byte}
\end{enumerate}

When IOZone reads from a file it has written to, it asserts that the file content is what it wrote previously to verify that the filesystem stores the data properly. This is not documented in the IOZone documentation\,\cite{iozoneIozoneFilesystemBenchmark} but was discovered during testing. However, while it asserts that file operations function correctly, it does not verify all aspects of the filesystem functionality. Further, as IOZone does not state that the file operations are tested, it cannot be assumed that the file operations are correct. Additionally, IOZone does not test if directory hierarchies work as expected, nor if multiple files can be stored at the same time. IOZone is a benchmarking tool used for evaluating the performance of the file operations of a filesystem, not testing the functionality. However, certain cases of the functionality of both \gls{FFS} and \gls{GCSF} was tested, and to support directory hierarchies and multiple files as expected. Future work could research the functionality of these filesystems utilizing online storage systems. \gls{APFS} is expected to have full functionality as it is a professionally developed and widely used filesystem.

While IOZone supports multiple different file operation tests, the thesis only uses a subset of these for benchmarking. Among other reasons, certain tests failed when ran on \gls{GCSF}. Furthermore, tests such as backward reading lack relevance as it tests a rare case of filesystem operations. The documentation of IOZone\,\cite{iozoneIozoneFilesystemBenchmark} claims that the software MSC Nastran uses \mbox{backward-read}. The documentation also mentions that only a few operating systems provide enhancements for backward reading, although many operating systems provide enhancements for \mbox{forward-reading}. As \gls{FFS} is intended as a \mbox{proof-of-concept} filesystem and is not intended as a \mbox{general-purpose} filesystem, only relevant tests were chosen. The IOZone benchmarking tests used in the thesis are: Forward- Read and Write, Forward- \mbox{Re-Read} and \mbox{Re-Write}, and Random- Read and Write. The \textit{Forward} specifier will sometimes be omitted in the thesis when the tests are referenced. For instance, when mentioning the Read test, we refer to the Forward Read test.

The IOZone documentation\,\cite{iozoneIozoneFilesystemBenchmark} states that to get the most accurate performance results from the benchmarking, the maximum file size of the tests should be set to a value bigger than the filesystem cache. While the \gls{FFS} cache limit is known to be \SI{5}{\mega\byte}, the cache size limit or the existence of such a limit for the other filesystems, such as \gls{GCSF}, is unknown. The documentation states that when the cache is unknown, it should be set to greater than the physical memory of the system. However, as the memory of the computer where the benchmarking is run is \SI{16}{\giga\byte}, this is bigger than reasonable for testing \gls{FFS} and \gls{GCSF}. Each doubled file size takes exponentially much more time as both the file size and the buffer size are doubled. Further, it has been found that both \gls{GCSF} and \gls{FFS} occasionally crash during benchmarking due to, among other factors, unstable internet connections, meaning that a benchmarking test of \SI{16}{\giga\byte} might never be complete due to the filesystem crashing first. The file sizes used for the IOZone tests are therefore set as:
\begin{enumerate}
	\item \SI{1024}{\kilo\byte},
	\item \SI{2048}{\kilo\byte},
	\item \SI{4096}{\kilo\byte},
	\item \SI{8192}{\kilo\byte}, and
	\item \SI{16384}{\kilo\byte}
\end{enumerate}
The buffer sizes tested are:
\begin{enumerate}
	\item \SI{4}{\kilo\byte},
	\item \SI{8}{\kilo\byte},
	\item \SI{16}{\kilo\byte},
	\item \SI{32}{\kilo\byte},
	\item \SI{64}{\kilo\byte},
	\item \SI{128}{\kilo\byte},
	\item \SI{256}{\kilo\byte},
	\item \SI{512}{\kilo\byte},
	\item \SI{1024}{\kilo\byte},
	\item \SI{2048}{\kilo\byte},
	\item \SI{4096}{\kilo\byte},
	\item \SI{8192}{\kilo\byte}, and
	\item \SI{16384}{\kilo\byte}
\end{enumerate}
% TODO: Test with size up to 256MB? Maybe even 512MB to see real difference
However, the maximum buffer size for each file size is the file size itself. For instance, for a file size of \SI{4096}{\kilo\byte}, IOZone will run the tests for buffer sizes up to, and including, \SI{4096}{\kilo\byte}. It can not run tests with a buffer size greater than \SI{4096}{\kilo\byte}.

When benchmarking the filesystems using IOZone, an argument is passed to include the time to close a file (using the \texttt{close} filesystem operation) in the total time of a test. This is important as \gls{FFS}, and potentially other filesystems save the data to the storage medium only after the device is closed. In the case of \gls{FFS}, if the time of closing the file was not included, the performance of the filesystem would appear to be higher than it is.

IOZone produces a log of the benchmarking results for the filesystem it benchmarked. This log contains a report of each test (file operation) with performance data for each file size, and for each buffer size for each file size benchmarked for the test. The performance of the filesystem is measured in kilobytes per second.

The benchmarking of \gls{FFS} and \gls{GCSF} were both started simultaneously as they both depend on an internet connection. For a fair comparison of the two filesystems, they should be run with similar internet connection constraints. During the benchmarking of the two filesystems, an automatic speed test was conducted every five minutes to survey the current internet connection. The speed test uses Bredbandskollen's command line interface tool\,\cite{internetstiftelsenBredbandskollenCLIBredbandskollen} which measures the latency, upload-, and download speed of an internet connection to a measurement server in Sweden, Norway, or Denmark\,\cite{internetstiftelsenMerOmBredbandskollen}. The benchmarking tests of \gls{FFS} and \gls{GCSF} were carried out in Amsterdam in The Netherlands using an ethernet connection to a \mbox{fiber-connected} router. While the internet connection to the measurement server is not sure to be equal to the internet connection to the servers of Flickr or Google Drive, it is used as a reference point of the internet connection.