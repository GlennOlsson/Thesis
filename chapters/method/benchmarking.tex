\section{Benchmarking}
This sections describes the methodology and execution of the different filesystem benchmarks. Two different filesystems that are relevant to FFS are compared with the result of two different instances of FFS; one instance that uses Flickr as its OWS, and one instance that uses a FOWS by storing the encoded images in the local filesystem on the test machine.

\subsection{Filesystems}
To analyze the performance of FFS, a filesystem benchmarking tool is used to compare FFS against other filesystems that are relevant to FFS. The filesystems FFS is compared to are:
\begin{enumerate}
	\item An encrypted APFS partition on a SSD,
	\item An instance of GCSF, and,
	\item An instance of FFFS using an encrypted APFS filesystem on a SSD as its FOWS.
\end{itemize}
The encrypted APFS filesystem was used as reference for a local filesystem without required internet connection. It is the local filesystem of the development environment for FFS. It was selected as it will gives the analyze an example of a modern, well-used and fast filesystem, and how the benchmark data of FFS and other filesystems looks compared to this local filesystem.

GCSF was selected to compare FFS against another network-based filesystem. While GCSF is not a steganographic filesystem, it is a filesystem which stores its data on an OWS, namely Google Drive. The reason GCSF was used instead of, for instance, the official Google Drive mountable filesystem volume provided by the Google Drive Desktop application, is that GCSF provides instant upload of the files and directories to Google Drive using the Google Drive REST API. The instant upload provided by GCSF enables us to measure the duration of a file operation easily. For instance, a write operation on a file in GCSF will not complete before the new file data has been completely stored on Google Drive. Another reason why GCSF was chosen was because it is a recent filesystem compared to other related filesystems. Some of the other filesystems discussed in Related filesystems, Section~\ref{sec:rel_fs}, were developed many years before FFS and thus do no longer work as expected, for instance due to changes in the API, or that the OWS manages the uploaded data differently than previously.

The instance of FFFS using an FOWS of an encrypted APFS was chosen to be compared to FFS so that the duration time of the FUSE filesystem operations could be analyzed further. As the filesystem operations of FFFS are similar to the ones of FFS, other than the network request being replaced by local filesystem operations, it is possible to analyze the effect the OWS latency, the OWS internet connection bandwidth, and the OWS data processing speed has on the filesystem performance. 
%Further, as the FOWS used by FFFS (encrypted APFS) is also analyzed and benchmarked, the computation time of the FOWS filesystem operations can be deduced from the benchmark results of FFFS. This enables us to analyze the speed of FFS, independent of the OWS used. 
Comparing the benchmark results of FFFS and APFS allows us to analyze the FFS overhead as FFFS is dependent on the performance of APFS. Especially for file operations where FFFS must interact with the storage medium, for instance write operations and read operations for files not in the cache, FFFS cannot outperform APFS as it will require the execution time of the APFS file operation as well as the internal FFS computation time.

\subsection{Tools}
IOZone\,\cite{IozoneFilesystemBenchmark} is a filesystem benchmarking tool used to analyze the performance of filesystem file operations using different tests on a file\,\cite{iozoneIozoneFilesystemBenchmark}. Examples of tests that IOZone provides support for are: reading and writing, reading and writing randomly, and reading backwards. Each test can be run with different file sizes and different buffer sizes used for the read or write operation. Normally, multiple buffer sizes are used for each test, for each file size tested. The buffer size starts at \SI{4}{\kilo\byte} and multiplies by two up to a buffer size equal to the file size. Multiple file sizes are often used for the benchmarking tests as well. For instance, one could run the IOZone tests with file size \SI{1024}{\kilo\byte} and \SI{2048}{\kilo\byte}, which would run the following values of the file size and buffer size for each test specified:
\begin{enumerate}
	\item File size = \SI{1024}{\kilo\byte}, buffer size = \SI{4}{\kilo\byte},
	\item File size = \SI{1024}{\kilo\byte}, buffer size = \SI{8}{\kilo\byte},
	\item File size = \SI{1024}{\kilo\byte}, buffer size = \SI{16}{\kilo\byte},
	\item File size = \SI{1024}{\kilo\byte}, buffer size = \SI{32}{\kilo\byte},
	\item File size = \SI{1024}{\kilo\byte}, buffer size = \SI{64}{\kilo\byte},
	\item File size = \SI{1024}{\kilo\byte}, buffer size = \SI{128}{\kilo\byte},
	\item File size = \SI{1024}{\kilo\byte}, buffer size = \SI{256}{\kilo\byte},
	\item File size = \SI{1024}{\kilo\byte}, buffer size = \SI{512}{\kilo\byte},
	\item File size = \SI{1024}{\kilo\byte}, buffer size = \SI{1024}{\kilo\byte},
	\item File size = \SI{2048}{\kilo\byte}, buffer size = \SI{4}{\kilo\byte},
	\item File size = \SI{2048}{\kilo\byte}, buffer size = \SI{8}{\kilo\byte},
	\item File size = \SI{2048}{\kilo\byte}, buffer size = \SI{16}{\kilo\byte},
	\item File size = \SI{2048}{\kilo\byte}, buffer size = \SI{32}{\kilo\byte},
	\item File size = \SI{2048}{\kilo\byte}, buffer size = \SI{64}{\kilo\byte},
	\item File size = \SI{2048}{\kilo\byte}, buffer size = \SI{128}{\kilo\byte},
	\item File size = \SI{2048}{\kilo\byte}, buffer size = \SI{256}{\kilo\byte},
	\item File size = \SI{2048}{\kilo\byte}, buffer size = \SI{512}{\kilo\byte},
	\item File size = \SI{2048}{\kilo\byte}, buffer size = \SI{1024}{\kilo\byte}, and
	\item File size = \SI{2048}{\kilo\byte}, buffer size = \SI{2048}{\kilo\byte}
\end{enumerate}

When IOZone reads from a file it has written to, it asserts that the file content is what it wrote previously to verify that the filesystem stores the data properly. This is not documented in the IOZone documentation\,\cite{iozoneIozoneFilesystemBenchmark} but has been discovered during testing. However, while it asserts that file operations function correctly, it does not verify all aspects of the filesystem functionality. Further, as IOZone does not state that the file operations are tested, it cannot be assumed that the file operations are correct. IOZone does also not test if directory hierarchies work as expected, nor if multiple files can be stored at the same time. IOZone is a benchmarking tool used for evaluating the performance of the file operations of a filesystem, not test the functionality. Although, the thesis has tested cases of the functionality aspect of both FFS and GCSF, and found that they support directory hierarchies and multiple files as expected. Future work could research the functionality aspect of these filesystem utilizing online storage systems. APFS is expected to have full functionality as a professionally developed and widely used filesystem.

While IOZone supports multiple different file operation tests, the thesis only uses a subset of these for the benchmarking. Among other reasons, certain tests failed when run on GCSF. Further, tests such as backwards reading lack relevance as it tests a rare case of filesystem operations. The documentation of IOZone\,\cite{iozoneIozoneFilesystemBenchmark} claims that the software MSC Nastran uses backwards read. The documentation also mentions that only a few operating systems provide enhancements for backwards reading, although many operating systems provide enhancements for forward reading. As FFS is intended as a proof-of-concept filesystem, and is not intended as a general-purpose filesystem, only relevant tests were chosen. The IOZone benchmarking tests used in the thesis are: Forward read and write, forward re-read and re-write, and random read and write.

The IOZone documentation\,\cite{iozoneIozoneFilesystemBenchmark} states that to get the most accurate performance results of the benchmarking, the maximum file size of the tests should be set to a value bigger than the filesystem cache. While the FFS cache limit is known to be \SI{5}{\mega\byte}, the cache size limit or the existence of such a limit for the other filesystems, such as GCSF, is unknown. The documentations states that when the cache is unknown, it should be set to greater than the physical memory of the system. However, as the memory of the computer where the benchmarking is run is \SI{16}{\giga\byte}, this is bigger than reasonable for testing FFS and GCSF. Each doubled file size takes exponentially much more time as both the file size and the buffer size is doubled. Further, it has been found that both GCSF and FFS might occasionally crash during benchmarking due to numerous factors, meaning that a benchmarking test of \SI{16}{\giga\byte} might never complete due to the filesystem crashing first. The file sizes used for the IOZone tests are therefore set as:
\begin{enumerate}
	\item \SI{1024}{\kilo\byte},
	\item \SI{2048}{\kilo\byte},
	\item \SI{4096}{\kilo\byte},
	\item \SI{8192}{\kilo\byte}, and
	\item \SI{16384}{\kilo\byte}
\end{enumerate}
The buffer sizes tested are:
\begin{enumerate}
	\item \SI{4}{\kilo\byte},
	\item \SI{8}{\kilo\byte},
	\item \SI{16}{\kilo\byte},
	\item \SI{32}{\kilo\byte},
	\item \SI{64}{\kilo\byte},
	\item \SI{128}{\kilo\byte},
	\item \SI{256}{\kilo\byte},
	\item \SI{512}{\kilo\byte},
	\item \SI{1024}{\kilo\byte},
	\item \SI{2048}{\kilo\byte},
	\item \SI{4096}{\kilo\byte},
	\item \SI{8192}{\kilo\byte}, and
	\item \SI{16384}{\kilo\byte}
\end{enumerate}
However, the maximum buffer size for each file size is the file size itself. For instance, for a file size of \SI{4096}{\kilo\byte}, IOZone will run the tests for buffer sizes up to, and including, \SI{4096}{\kilo\byte}. It can not run tests with a buffer size greater than \SI{4096}{\kilo\byte}.

When benchmarking the filesystems using IOZone, an argument is passed to include the time to close a file (using the \texttt{close} filesystem operation) in the total time of a test. This is important as FFS, and potentially other filesystems, saves the data to the storage medium only after the device is closed. In the case of FFS, if the time of closing the file was not included, the performance of the filesystem would be appear to be higher than it actually is.

IOZone produces a log of the benchmarking results for the filesystem it benchmarked. This log contains a report of each test (file operation) with performance data for each file size, and for each buffer size for each file size benchmarked for the test. The performance of the filesystem is measured in kilobytes per second.

The benchmarking of FFS and GCSF were both run simultaneously as they both depend on an internet connection. For a fair comparison of the two filesystems, they should be run with similar internet connection constraints. During the benchmarking of the two filesystems, an automatic speed test was conducted every five minutes to survey the current internet connection. The speed test uses Bredbandskollen's command line interface tool\,\cite{internetstiftelsenBredbandskollenCLIBredbandskollen} which measures the latency, upload-, and download speed of an internet connection to a measurement server in Sweden, Norway, or Denmark\,\cite{internetstiftelsenMerOmBredbandskollen}. The benchmarking tests of FFS and GCSF were carried out in Amsterdam in The Netherlands using a ethernet connection to a fiber-connected router. While the internet connection to the measurement server is not sure to be equal to the internet connection to the servers of Flickr or Google Drive, it is used as a reference point of the internet connection.