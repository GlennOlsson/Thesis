\section{FFS}
The artifact that was developed as a result of this thesis is the \acrfull{FFS}. It uses an \gls{OWS} to store the data but behaved as a mountable filesystem for the users. As mentioned in Section~\ref{sec:delim} the filesystem is a \mbox{proof-of-concept} and does not support all functionalities that other filesystems do, such as links or access permissions. The reasoning is that these behaviors are not required for a useable system. Additionally, when comparing \gls{FFS} to distributed filesystems such as Google Drive, many of these other filesystems also do not support functionality such as links.

\subsection{Design overview}
\gls{FFS} uses images to store the data of files, directories, and the inode table of the filesystem. These images are uploaded to an \gls{OWS}, such as Flickr, as image posts. As mentioned in Section~\ref{sec:ows}, there can be limitations of the size of these posts for certain \gls{OWS}s. To support file sizes bigger than these limitations, bigger files will be split into multiple posts, requiring \gls{FFS} to keep track of a list of posts. Figure~\ref{fig:ffs_inode_diag} presents the basic outline of \gls{FFS} and an example content of the filesystem. \gls{FFS} is based on the idea of inode filesystems and uses an inode table to store information about the files and directories in the filesystem. However, instead of an inode pointing to specific blocks in a disk, the inode table of \gls{FFS} will instead keep track of the id numbers of the posts on the \gls{OWS} where the file or directory is located. The inode table entry for each file or directory will also contain metadata about the entry, such as its size and a boolean indicating if the entry is a directory or not.

\begin{figure}[!ht]
	\begin{center}
	  \includegraphics[width=0.8\textwidth]{figures/ffs_inode_diagram.png}
	\end{center}
	\caption{Basic structure of \gls{FFS} \mbox{inode-based} structure}
	\label{fig:ffs_inode_diag}
\end{figure}

The directories and inode table are represented as classes in C++. Appendix~\ref{app:inode_dir_code} visualizes the main attributes of the \texttt{Directory}, \texttt{InodeTable}, and \texttt{InodeEntry} classes. There can be multiple \texttt{Directory} and \texttt{InodeEntry} objects in the computers' memory and the filesystem, but there will only exist one relevant \texttt{InodeTable} instance. The \texttt{Directory} class is a data structure that stores mappings between filenames and the files' and directories' inode, for all files and directories stored in that directory. The \texttt{InodeEntry} is a data structure that keeps track of a file's or directory's information, such as where the data is stored and its metadata, such as size and creation timestamp. The \texttt{InodeTable} stores a mapping between an inode and the file's \texttt{InodeEntry}. The \texttt{InodeTable} has always at least one entry which is the root directory. This entry has a constant inode value of 0 for simplicity to look up the root directory. With the help of the root directory, all the files lower in the directory hierarchy can be found. The inode of all files and directories other than the root directory has a unique inode greater than 0. The \texttt{InodeTable} is always the most recent image saved on the \gls{OWS}, making it easy to find it on the \gls{OWS}.

To read the content of a known filename in a directory has three steps using these data structures:
\begin{enumerate}
	\item The \texttt{Directory} object of the directory provides the inode of the given filename.
	\item The inode is used to get the \texttt{InodeEntry} from the \texttt{InodeTable}.
	\item Using the inode entry, the file can be located.
\end{enumerate}
The location of a file or directory is an ordered list of unique IDs of the image posts on the \gls{OWS}. The data received by downloading these images, decoding them (as described in Subsection~\ref{subsec:file_enc_dec}), and concatenating them, can be read as a file or represented as a \texttt{Directory} object, depending on whether the \texttt{InodeEntry} is marked as a file or a directory. 

As directories only know the filename's inode, the \texttt{Directory} object does not have to be updated (and thus uploaded) when a file or directory in it is edited, for instance adding data. Only the \texttt{InodeEntry}, and thus the \texttt{InodeTable}, needs to be updated with the new post IDs of the new file or directory. This saves computation time as every request to the \gls{OWS} takes time. However, if the filename is edited or the file or directory is moved to another location, the parent directory of the file or directory would have to be edited, and thus its corresponding \texttt{Directory} object has to be updated.

When a new file or directory is created, it is saved in its parent directory with its filename and an inode. The same inode is used in the inode table to keep track of the file's or directory's inode entry. As shown in Appendix~\ref{app:inode_dir_code}, the inode is represented as an unsigned \mbox{32-bit} integer. The inode is calculated by adding one to the currently greatest inode. This means that new files and directories will always receive a greater inode value than the ones currently in the inode table. This naÃ¯ve approach to inode generation does not take into account that there might be an available inode less than the greatest inode in the inode table (for instance, due to the deletion of a previously created file). However, this inode generation approach is fast and will not be a problem until the integer overflows. As the inode is represented using a \mbox{32-bit} integer, \gls{FFS} would need to have saved over four billion files before the inode value would overflow. This scenario is outside the scope of this \mbox{proof-of-concept} filesystem.

\gls{FFS} does not support all filesystem operations that are implementable through \gls{FUSE}, instead, \gls{FFS} implements a subset of them as shown in Table~\ref{tbl:fs_impl_op}. The implemented operations are the most essential operations required for a working filesystem\,\cite{kuenningCS135FUSEDocumentation2010}. Operations such as \texttt{chown} provide extended capabilities of the filesystem but these are not required for a \mbox{proof-of-concept} filesystem. The functionality of the filesystem operations implemented by \gls{FFS} and their implementation details are described in Subsection~\ref{subsec:file_op}. 

\begin{table}[!ht]
	\begin{center}
		\caption{Filesystem operations implementable trough the \gls{FUSE} \gls{API}, and whether or not \gls{FFS} implements them}
		\begin{tabular}{| c | c |}
			
			\hline
			\begin{tabular}{@{}c@{}}\textbf{Filesystem operations} \\ \textbf{implemented by FFS}\end{tabular} &
				\begin{tabular}{@{}c@{}}\textbf{Filesystem operations} \\ \textbf{\textit{not} implemented by FFS}\end{tabular} \\
			\hline
			\hline
			\texttt{open} & \texttt{readlink}\\
			\texttt{opendir} & \texttt{symlink}\\
			\texttt{release} & \texttt{link}\\
			\texttt{releasedir} & \texttt{chmod}\\
			\texttt{create} & \texttt{chown}\\
			\texttt{mkdir} & \texttt{fsync}\\
			\texttt{read} & \texttt{fsyncdir}\\
			\texttt{readdir} & \texttt{lock}\\
			\texttt{write} & \texttt{bmap}\\
			\texttt{rename} & \texttt{setxattr}\\
			\texttt{truncate} & \texttt{getxattr}\\
			\texttt{ftruncate} & \texttt{listxatt}\\
			\texttt{unlink} & \texttt{ioctl}\\
			\texttt{rmdir} & \texttt{flush}\\
			\texttt{getattr} & \texttt{poll}\\
			\texttt{fgetattr} & {}\\
			\texttt{statfs} & {}\\
			\texttt{access} & {}\\
			\texttt{utimens} & {}\\
			
			\hline

		\end{tabular}
		\label{tbl:fs_impl_op}
	\end{center}
\end{table}

A file, a \texttt{Directory}, or the \texttt{Inode Table} has to be uploaded to the \gls{OWS} when it is modified to save its current information. As it takes time to make requests to the \gls{OWS}, \gls{FFS} is designed to make as few requests as possible while still saving the data required. Therefore, only the directory or file that is affected by a change is uploaded to the system, while those unaffected can remain the same. The inode table has to be updated with every change of a file or directory as it contains the location of the file or directory.

\gls{FFS} can be mounted to the local filesystem using \gls{FUSE}, similar to how you can mount a network drive or a \gls{FTP} server. The mounted \gls{FFS} volume operates similarly to any other drive and can be accessed using, for instance, Mac's Finder or a shell terminal.

\subsection{Cache}
\gls{FFS} implements a simple \mbox{in-memory} \gls{LRU} cache for the downloaded content. The cache consists of two data structures: 
\begin{description}
	\item[Cache Map] a mapping between a post ID and its image data, and
	\item[Cache Queue] a queue keeping track of the cached post IDs.
\end{description}
The cache stores a maximum of 20 image posts. The data stored in the cache is the encrypted image data. To avoid \gls{FFS} using too much memory, the cache is configured so that images greater than \SI{5}{\mega\byte} are not cached. Each time an image is uploaded or downloaded, it is added to the Cache Map with its post ID as the key. The post ID is also added to the beginning of the Cache Queue. If the Cache Queue exceeds 20 elements, the last element of the queue is removed, and the corresponding entry in the Cache Map is erased, thus the entry is fully erased from the cache. The queue ensures that the cache is limited to 20 entries, and by using the \gls{FIFO} valuation method, the queue ensures that the oldest element in the cache is removed when the cache exceeds the limit. When a file or directory is removed from the filesystem, all its data is also removed from the cache, if it is stored there.

Before a post with a specified post ID is downloaded from the \gls{OWS}, the cache is checked to see if the cache is storing this post ID. If so, the stored image is returned. Otherwise, the process continues by downloading the image from the \gls{OWS} and then adding it to the cache. When the thesis states that a file or directory is downloaded, it is implied that the cache is also checked and the data is possibly returned by the cache instead of requiring a download of the data from the \gls{OWS}.

\gls{FFS} separately caches both the root directory and the inode table. As both of these data structures are used in many of the filesystem operations, it is important that they can be accessed quickly and not be removed from the cache. Their cache entries are updated when the files are uploaded to the \gls{OWS}. They are stored as an instance of an \texttt{InodeTable} object and an instance of a \texttt{Directory} object.

\gls{FFS} separately also caches the inode of open files and the inode the open file's parent directory. The open file's data is also cached in memory if it has have been read or written to while it is open. A file is opened with the use of the \texttt{open} or \texttt{create} filesystem operation, as described further down in Section~\ref{subsec:file_op}. When a file is opened it is associated with a file handle identifier which is used for subsequent filesystem operations to refer to the file rather than using the path to the file in the filesystem. When a user is reading or writing data to a file, multiple \texttt{read} or \texttt{write} file operations might be executed. For instance, when writing a \SI{100}{\byte} file two \texttt{write} operations might be executed:
\begin{itemize}
	\item One with \texttt{offset = 0} and with a buffer size of \SI{50}{\byte} bytes, and
	\item One with \texttt{offset = 50} and with a buffer size of \SI{50}{\byte}.
\end{itemize}
The amount of \texttt{read} or \texttt{write} operations required to read or write data depends on the amount of data to read or write, the buffer sizes used by the file operation which depends on the buffer sizes supported by the filesystem. macFUSE can be mounted with a maximum buffer size of \SI{32}{\mega\byte}\,\cite{fleischerMountOptionsOsxfuse2020}. To save computation time by not having to download the file from the \gls{OWS}, or even decrypt the image data found in \gls{FFS}s regular cache, \gls{FFS} stores the file data separately in memory. When a file with a file handle is modified or read, \gls{FFS} checks if the file handle has any cached data associated with it, before it is checking the regular cache for the post ID. If there is data associated with the file handle, then this data is used for the file operation. If the file operation was a modifying operation, such as a \texttt{write} operation, the new data is associated with the file handle and stored in memory. When the file is closed with a subsequent \texttt{close} file operation, the modified data is encoded, encrypted and uploaded to the \gls{OWS}. There is no limit to how many files can be open in the filesystem at the same time, nor how much modified data can be associated with a file handle. Further, if a file is not closed, the associated data is not disassociated with the file handle and is kept in the memory until the filesystem is shut down.

\subsection{Encoding and decoding objects}
\label{subsec:file_enc_dec}
Entities that \gls{FFS} stores on the \gls{OWS}, and therefore also encodes and decodes, are: files, \texttt{Directory} objects, and the \texttt{Inode Table} object. All of these entities are stored on the \gls{OWS} using PNG images with \mbox{16-bit} \gls{RGB} color depth. The inode table and the directories are represented as C++ objects in memory during runtime but are serialized into a binary representation before they are encoded into images. The files saved to \gls{FFS} are read into memory in a binary format before being encoded into images. All the data encoded into images are encoded similarly, and a detailed description of the binary structures can be found in Appendix~\ref{app:binary_rep}. 

The input to the image encoder is the binary data do encode as an image. A header (\gls{FFS} header) is prepended to the binary data, containing among other things, the size of the data and a timestamp of when the data was encoded. The \gls{FFS} header and the input data are encrypted using authenticated encryption, utilizing \gls{GCM} and \gls{AES}. The key used for the encryption is derived using the \gls{HKDF} function utilizing the \gls{SHA}-256 hashing algorithm, along with a random \SI{64}{\byte} salt vector, \mbox{re-generated} every time new data is encrypted. The salt is stored with the cipher to ensure that the decryption algorithm uses the same salt to derive the decryption key. The secret used in the \gls{HKDF} is a password provided by the user. \gls{HKDF} also uses a random \gls{IV}, \mbox{re-generated} every time new data is encrypted. The length of the \gls{IV} is set to 12 bytes. The resulting data from the encryption is the salt, the \gls{IV}, and the encrypted cipher (including the authentication tag). These three data points are concatenated into a string of bytes. This string of bytes is referred to as the \gls{CED}.

The dimensions of an \gls{FFS} image is based on the amount of bytes stored, as described in Section~\ref{sec:data_storage}. The stored data is the CED, prepended with the Length of the \gls{CED} (the \gls{LCED}) using 4 bytes. For an image of $X = ceil(\frac{4 + LCED}{6})$ pixels, \gls{FFS} will set the width $w$ of the image as $w = ceil(\sqrt{X})$. Further, the height $h$ of the image is set as $h = ceil(\frac{X}{w})$. This will require $(w * h) - X$ filler bytes and will create an image with similar height and width. For certain values of $X$, $h$ will be equal to $w$. For other values of $X$, $h = w-1$. The resulting data encoded as pixels in the image is, in order:
\begin{itemize}
	\item 4 bytes representing the \gls{LCED},
	\item The \gls{CED} data, and
	\item Filler bytes.
\end{itemize}
The content of the filler bytes are randomized.

The data consisting of the \gls{LCED}, CED, and filler bytes are encoded into \gls{PCD} for a PNG with 16 \gls{RGB} bit color depth using the Magick++ library. The result is an image with a high probability of what looks like randomized colors for each pixel. This is because most pixels are encrypted data and therefore the bytes representing this data are seemingly random.

To decode an \gls{FFS} image, the decoder first interprets the 4 first bytes as the \gls{LCED}. The salt and \gls{IV} are retrieved from the \gls{CED} as they are of known length. The decryption key is derived using the \gls{IV} and salt and results in the same key as the encryption key because \gls{AES} is a symmetric cipher algorithm. The remaining bytes of the \gls{CED} ($\gls{LCED} - len(IV) - len(salt)$ bytes) are decrypted using the decryption key. The decrypted data consists of the \gls{FFS} header concatenated with the original stored data. The \gls{FFS} header is asserted to be in the correct format before the original binary data is returned from the decryption function. Figure~\ref{fig:file_enc_dec} visualizes the encoder and decoder for all data saved in \gls{FFS}.

\begin{figure}[!ht]
	\begin{center}
	  \includegraphics[width=1.0\textwidth]{figures/encoder_decoder.png}
	\end{center}
	\caption[Simple visualization of the encoder and decoder of \gls{FFS}]{Simple visualization of the encoder and decoder of \gls{FFS}. The input of the encoder is the binary data to store in \gls{FFS}, eg. a file, and the output is the \gls{FFS} image to upload to the \gls{OWS}. The input to the decoder is an \gls{FFS} image, and the output is the binary data stored on \gls{FFS}, eg. a file}
	\label{fig:file_enc_dec}
\end{figure}

The encryption and decryption methods used are \mbox{state-of-the-art} solutions as defined and implemented by Crypto++\,\cite{CryptoLibraryFree}. Crypto++ is a \mbox{widely-used} and \mbox{well-maintained} C++ library for cryptography, and as of writing has no reported CVE security vulnerabilities for the functionality used by \gls{FFS}\,\cite{CryptoppSecurityVulnerabilities}.

An \gls{FFS} image has an upper size limit, defined by the \gls{OWS} used. If the data to be stored in \gls{FFS}, such as a file, exceeds this limit, it is split into multiple data arrays of sizes less than this limit. Each data array is encrypted and encoded as images independently of each other, and will be encrypted using different salts and \gls{IV}s. Only the inode table stores the different post IDs in the order they are encoded in. While files and directories stored in \gls{FFS} can be separated into multiple images, the inode table is limited to only one image for simplicity when interacting with the \gls{OWS}. This introduces a size limit of the inode table, limiting the filesystem. More details about the limits of \gls{FFS} are found in Subsection~\ref{subsec:ffs_limits}.

\subsection{Online web services}
As \gls{FFS} is a \mbox{proof-of-concept} filesystem, it only uses one \gls{OWS} as its storage medium. However, for a production filesystem, multiple \gls{OWS}s would be beneficial. This would enable features such as redundancy by using replication over multiple \gls{OWS}s, for instance in case one \gls{OWS} would stop working.

The initial intention of \gls{FFS} was to use Twitter as the \gls{OWS}. Initial research for the thesis found that it was possible to upload a file and download the same file without any data loss. However, it was later found that this was not a reliable conclusion. Some images uploaded to Twitter were converted to another image format when they were stored by Twitter, which meant that the decoder could not decode the data as it expected another image format. Other images were compressed or \mbox{re-coded} which led to data loss when downloading the image. As the decoder of \gls{FFS} images relies on a specific binary representation of the image, this meant that the images could not be decoded into the previously uploaded data. Twitter has previously publicly announced changes to the way they store images\,\cite{nolanobrienUpcomingChangesPNG2018} and even suggested workarounds\,\cite{nolanobrienFeedbackUpcomingChanges2019} for users who are concerned about the potential data loss. However, during research for the thesis, it was concluded that the workarounds mentioned in \cite{nolanobrienFeedbackUpcomingChanges2019} no longer work on Twitter. For instance, some PNG images less than 900x900px that have been uploaded to Twitter, have not been able to be downloaded as the same image, which contradicts the workaround mentioned by the Twitter employee. Further changes may have been made to the data management of images on Twitter since the initial research for the thesis; however, an official announcement has not been found.

Flickr saves the original version of the uploaded image and thus it can be used to download the same image as was uploaded. This also means that data that is encoded into an \gls{FFS}-encoded image can be uploaded, downloaded, and decoded into the same data as before. While they do not assure that they will always support original images, they also do not indicate that this would change. Therefore, Flickr can be used at this moment for the \mbox{proof-of-concept} filesystem that \gls{FFS} is. A \mbox{free-tier} Flickr account is therefore used for \gls{FFS}. However, as was noted in Section~\ref{subsec:ows_flickr}, only the user can download the original file - other users might get another file when downloading the image post. 

Flickr provides an extensive free REST \gls{API} for \mbox{non-commercial} use. A user can create applications and generate access tokens for the application. These application tokens are later used to request tokens from users who authenticate using Flickr's web interface and allow the application to do requests for the user. The application will then receive access tokens for the user, which are used to authenticate with the \gls{API} for the \gls{API} calls that require authentication.

Flickr provides the ability to search for all the images posted by a user and to sort these results by the time of posting. In \gls{FFS}, every time an image is uploaded to Flickr, it is due to some modification in the filesystem, for instance, a write operation to a file or a creation of a new directory. For every modification in the filesystem, the inode table will have to be updated. Therefore, we can ensure that the inode table is always the most recently uploaded image to Flickr by configuring \gls{FFS} to upload all other images first, for instance, the newly written file. This provides \gls{FFS} with a simple way of querying the inode table from Flickr - by simply requesting the most recently uploaded image on the Flickr account.

While the Flickr \gls{API} is extensive in its functionality, \gls{FFS} only uses a few of the provided capabilities; specifically \gls{FFS} uses:
\begin{itemize}
	\item Upload an image and return the post ID,
	\item Query the most recent image by a user, and return the URL and post ID of the original uploaded image,
	\item Get the URL to the original uploaded image given a post ID,
	\item Remove an image given a post ID, and,
	\item Get the image data of the image given its URL.
\end{itemize}

For instance, to download the original image given a post ID, two requests are required:
\begin{enumerate}
	\item Get the URL to the original uploaded image given a post ID,
	\item Get the image data of the image given its URL.
\end{enumerate}

For benchmarking purposes, a fake variant of \gls{FFS}, \gls{FFFS}, has also been developed. \gls{FFFS} uses a \gls{FOWS}, which stores the data on the local \gls{APFS} filesystem. The \gls{FOWS} is used by \gls{FFFS} just as Flickr is used by \gls{FFS}, by storing encoded images on it. By storing the images on the local filesystem, the filesystem operation's duration is shorter as the local filesystem operations are in general faster than the network requests. This allows us to analyze the theoretical performance limit of \gls{FFS}, and how it would perform if the \gls{OWS} used had very low latency and the network connection to the \gls{OWS} had very high bandwidth and low delay. By analyzing \gls{FFFS}, we can also estimate how much of the filesystem operation time is affected by the time of the network requests. The time $T$ of an \gls{FFS} filesystem operation can be modeled like:
$$
	T = t_\text{ffs} + t_\text{ows}
$$
where $t_\text{ffs}$ is the time that \gls{FFS} takes, for example for a read operation on a file associated with a file handle;
\needspace{5\baselineskip}
\begin{itemize}
	\item to find the file in the inode table,
	\item decode and decrypt the image data,
	\item read the specified amount of data, and,
	\item to output the data.
\end{itemize}
This time will be approximately consistent for the same request for the same file size. However, computer memory cache misses/hits and process scheduling, among other factors, can fluctuate the value of $t_\text{ffs}$. In contrast, $t_\text{ows}$ is the total time required to complete all requests to the \gls{OWS} for a filesystem operation. For instance, for a similar read operation as above this consists of:
\needspace{5\baselineskip}
\begin{itemize}
	\item to download all the directories in the file path,
	\item query the Flickr \gls{API} for the URL pointing to the most recently uploaded image, and,
	\item to download the images representing the file to read.
\end{itemize}
Depending on the \gls{OWS}, the latency and bandwidth of the internet connection between the user's machine and the \gls{OWS}'s server can differ a lot. Duplicate requests to the same \gls{OWS} can also differ significantly due to, for instance, server load balancing and a difference in number of requests from other users at the time of the requests. Further, the request could be replaced by a fast cache hit in the \gls{FFS} cache. However, for a \gls{FOWS}, $t_\text{ows}$ can be replaced by $t_\text{fows}$ which will have approximately consistent values for duplicate operations, because the local filesystem is not affected by the network connection or the current traffic by other users of the \gls{OWS}. The local filesystem requests by other applications on the machine can also be minimized by not using other applications on the machine while running the benchmarking tool to ensure filesystem requests by the \gls{FOWS} can be handled quickly by the operating system. However, $t_\text{fows}$ is affected by, among other things, the underlying storage device of the local filesystem, process scheduling, and \gls{FFS} cache hits/misses which can still affect the value of $t_\text{fows}$.

Due to limitations in the library \texttt{Flickcurl} used for uploading images to Flickr, the image to be uploaded to Flickr first has to be saved to the local filesystem. \texttt{Flickcurl} reads the image from the disk, before uploading it. Therefore, \gls{FFS} saves a temporary file on the local filesystem when data is uploaded to Flickr. This temporary file is stored in the \texttt{/tmp} directory of the local filesystem and is removed by \gls{FFS} immediately after the file has been uploaded. However, it is not certain that the operating system removes or overwrites the file data on the storage device, and thus there are ways to recover the deleted data, by for instance adversaries\,\cite{llcsysdevlaboratoriesHowRecoverData2022,cedricAPFSDataRecovery2022,santosHowRecoverData2021}. Although, these methods require you to decrypt the \gls{APFS} volume, requiring the decryption password. Without this password, the data cannot be recovered. Even with the decryption password, it is not certain that the data is recoverable. If an adversary obtains proof that an \gls{FFS} image has been present in the \texttt{/tmp} directory, they could conclude that \gls{FFS} has been used to store data, reducing the deniability of the filesystem.

\subsection{Implemented filesystem operations}
\label{subsec:file_op}
This section gives a detailed description of all the \gls{FUSE} operations implemented by \gls{FFS}, and how they are implemented by \gls{FFS}. Further explanations about the intended functionality of the operations can be found in \citeauthor{kuenningCS135FUSEDocumentation2010}'s report\,\cite{kuenningCS135FUSEDocumentation2010}. 

The path of a file is sometimes provided for the filesystem operation and traversed by \gls{FFS} to understand the requested location. An example path is \texttt{/foo/bar/buz.txt} or \texttt{/foo/bar/baz/}. A path is traversed with the following \mbox{pseudo-code} shown in Listing~\ref{lst:traverse_path}.

\begin{lstlisting}[language=python, caption={Pseudocode of traversing a given path, returning the \texttt{Directory} and the filename}, label=lst:traverse_path,breaklines=true, basicstyle=\footnotesize, float]
# Traverse a given path and return the parent directory object
#  and filename of the path
traverse_path(path) -> (Directory, string):
	# Fetches inode table from the cache
	inode_table := get_inode_table()
	
	split_path := path.split("/")
	# The filename could be either the name of a file 
	#  or the name of a directory
	filename := split_path.last
	dirs := split_path.remove_last()

	# Get the root dir from the cache
	curr_dir = cache.get_root_dir()

	# While there are still directories to traverse,
	#  get the next directory in the list from the 
	# current directory
	while(!dirs.empty())
		dir_name := dirs.pop_first()
		inode := curr_dir.inode_of(filename=dir_name)
		inode_entry = inode_table.entry_of(inode=inode)
		# Download the image posts defined by the 
		#  post IDs in the inode entry
		curr_dir = download_as_dir(inode_entry)
	
	return (curr_dir, filename)

\end{lstlisting}

When traversing a path, \gls{FFS} has to fetch all parent directories in the hierarchy. The file or directory with the filename is not fetched while traversing the path, as it might not be necessary for the operation. All operations that rely on the path of a file or directory have to download all parent directories of the path. However, the directories in the path could be cached and therefore would not be required to be downloaded from the \gls{OWS}. Furthermore, the \texttt{open}, \texttt{opendir}, and \texttt{create} operations associate a file handle with a file or directory. This enables certain subsequent filesystem operations to use the file handle instead of traversing the string path. This saves time because the path traversing only occurs once for potentially multiple filesystem operations, and the result is saved in the filesystem state.

After every operation that modifies the inode table, the inode table is uploaded to the \gls{OWS} and cached. Therefore, it is assumed that the inode table is always up to date in memory and on the \gls{OWS}. This will be true as long as there are not multiple \gls{FFS} instances working with the same \gls{OWS} account at the same time. This multiuse scenario has undefined behavior as there is no locking implemented for \gls{FFS}.

All filesystem operations are synchronous unless specified. Further, \gls{FUSE} is running in \mbox{single-thread} mode meaning that a filesystem operation call must complete before another can begin. This helps limit the risk of data races as two processes cannot call different operations that, for instance, modify the inode table at the same time.

\subsubsection{open}
Given a path to a file, the file is associated with a file handle. The file handle is used in subsequent operations to avoid traversing the file path multiple times. The file is not downloaded from the \gls{OWS}, only the parent directories are downloaded during the path traversing as explained above. An \texttt{open} call must, eventually, be followed by a \texttt{release} call. Although, multiple other operation calls can occur between these events.

\subsubsection{create}
This operation creates an empty file in the filesystem given a path and associates a file handle with the file, similar to \texttt{open}. The empty file will not be uploaded to the \gls{OWS} as it has no data associated with it. A new entry is added to the parent directory with the filename and a generated inode, and the parent directory is updated in the \gls{OWS}. The new posts representing the parent directory in the \gls{OWS} are associated with the inode entry of the parent directory in the inode table, and the old posts are deleted in the \gls{OWS}. A new inode entry is also created in the inode table, representing the new, empty, file. The inode table is updated in the \gls{OWS}, and the old inode table is removed.

\subsubsection{release}
Given a file handle, this operation closes the file in the filesystem, disassociating the file handle from the file. The current states of the file and the inode table are saved to the \gls{OWS}, and the previous versions of the file and inode table are deleted from the \gls{OWS}. Subsequent operations for the file will require path traversing as the file handle can no longer be used.

The file must have a file handle associated with it before \texttt{release} is called. This requires a preceding \texttt{open} or \texttt{create} call for the file.

\subsubsection{opendir}
Given a path to a directory, the directory is associated with a file handle. The file handle is used in subsequent operations to avoid traversing the file path multiple times. The directory is not downloaded from the \gls{OWS}, only the parent directories are downloaded during the path traversing as explained above. An \texttt{opendir} call must, eventually, be followed by a \texttt{releasedir} call. Although, multiple other operation calls can occur between these events.

\subsubsection{releasedir}
Given a file handle, this operation closes the directory in the filesystem, disassociating the file handle from the directory. The current states of the directory and the inode table are saved to the \gls{OWS}, and the previous versions of the directory and inode table are deleted from the \gls{OWS}. Subsequent operations for the directory will require path traversing as the file handle can no longer be used.

The directory must have a file handle associated with it before \texttt{releasedir} is called. This requires a preceding \texttt{opendir} call.

\subsubsection{mkdir}
This operation creates an empty directory in the filesystem given a path. The directory is not uploaded to the \gls{OWS} as it has no data associated with it. The parent directory is modified and updated in the \gls{OWS}, and the old versions of the parent directory are deleted in the \gls{OWS}. The parent directory entry in the inode table is modified with the new posts, and a new entry is created for the new directory. The inode table is updated in the \gls{OWS}, and the old version of the table is removed from the \gls{OWS}.

As opposed to \texttt{create} for files, this operation does not associate a file handle with the directory.

\subsubsection{read}
This operation reads a number of bytes, starting from a set offset, from the file specified by the file handle. The data is read into a provided buffer. The full file is downloaded and read into memory, even if just a small part of the file is requested. The file is also cached so that subsequential requests for the same file are faster. 

\subsubsection{readdir}
This operation reads the filenames inside the directory specified by a file handle. The result includes all filenames in the directory, and the special \texttt{"."} and \texttt{".."} directories.

\subsubsection{write}
This operation writes $s$ bytes from a data array $a$, starting at the provided offset $o$, to the existing file at the provided file handle. All the data of the current file is read into memory. Starting from the offset, the new data from $a$ overwrites the current data of the file, until $s$ bytes have been written. If $o + s$ is greater than the file's size, the file size is set to $o + s$. If $o + s$ is less than the file's size, the data from position $o + s$ and forward remains the same, and the file size is not modified. See Figure~\ref{fig:write_flow} for a visualization of the result of a \texttt{write} operation given different offsets. The parent directory does not have to be modified. 

The file and inode table are not updated on the \gls{OWS}, this occurs instead in the subsequent \texttt{release} call. However, the data is associated with the file handle so that subsequent filesystem calls uses this new file data.

\begin{figure}[!ht]
	\begin{center}
	  \includegraphics[width=0.9\textwidth]{figures/write_flow.png}
	\end{center}
	\caption{Visualization of how the write operation handles different offsets.}
	\label{fig:write_flow}
\end{figure}

\subsubsection{rename}
This operation renames a file or directory to a new path. Both the old path and the new path have to be traversed to locate the parent directories and the file or directory to rename. The file or directory entry in the old parent directory is removed, and the old parent directory is updated to the \gls{OWS}. A new entry is created in the new parent directory, with the new filename. The new parent directory is updated to the \gls{OWS}. The inode entry of the renamed file or directory does not have to be modified. However, as both the old parent directories and the new parent directory are updated in the \gls{OWS}, their inode entries need to be updated with the new posts. The inode table is updated to the \gls{OWS} and the old table is removed from the \gls{OWS}. The old posts associated with the old parent directory and the new parent directory are removed from the \gls{OWS}.

The new path could be in the same directory as the file or directory currently is in. This will not affect the process mentioned above; however, the path will only have to be traversed once, and the parent directory will only be removed and updated once.

\subsubsection{truncate}
This operation truncates or extends the file in the given path, to the provided size $s$. The full current file is downloaded into memory. The data of the current file is written to a new buffer until either the file is fully written, or until $s$ bytes have been written. If the current file's size is smaller than $s$, the remaining bytes are written as the NULL character. The new file data is uploaded to the \gls{OWS}, and the old data is removed from the \gls{OWS}. The inode table entry is updated with the new posts and uploaded to the \gls{OWS}. The old inode table is removed from the \gls{OWS}.

\subsubsection{ftruncate}
This operation is similar to \texttt{truncate}, but is called from a user context which means it has a file handle associated with it. The operation truncates or extends the file in the given file handle, to the provided integer $s$. The full current file is read into memory, either from the \gls{OWS} or from the cache. The data of the current file is written to a new buffer until either the file is fully written, or until $s$ bytes have been written. If the current file's size is smaller than $s$, the remaining bytes are written as the NULL character.

The file and inode table are not updated to the \gls{OWS}, this occurs instead in the subsequent \texttt{release} call. However, the data is associated with the file handle so that subsequent filesystem calls uses this new file data.

\subsubsection{unlink}
This operation removes a file given the file path. The file is removed from the parent directory, and the parent directory is updated to the \gls{OWS}. The old parent directory data is removed on the \gls{OWS}. The removed file's entry in the inode table is also removed, and the inode table updates the entry for the parent directory with its new posts. The inode table is then updated on the \gls{OWS} and the old inode table is removed on the \gls{OWS}. Finally, the data of the removed file is removed from the \gls{OWS}. The last step is not necessary for a working filesystem; however, to save space on the \gls{OWS}, this is done. If the \gls{OWS} permits unlimited images and sizes, this step could be omitted to save time.

\subsubsection{rmdir}
Similar to \texttt{unlink}, this operation removes the directory at the path. The directory and all its subdirectories are traversed, and the post IDs of these files and directories are recorded for deletion later. Following this, the entry of the removed directory is removed from the parent directory. The inode entry for the removed directory is removed. The parent directory is updated to the \gls{OWS}, and the inode table is updated with the new posts of the parent directory. Following this, the inode table is updated to the \gls{OWS}. The old parent directory and the old inode table are removed from the \gls{OWS}.

The operation also starts a new thread, where all the posts of files and subdirectories inside the removed directory, are removed from the \gls{OWS}. They are removed to save space on the \gls{OWS}, and a separate thread is used to minimize the delay for subsequent file operations. There is no data race involved as the \gls{API} is \mbox{thread-safe}, and the posts are no longer associated with any data structures on the main thread and would not be accessed there. This also means that this thread can be run with a lower priority.

\subsubsection{getattr}
This operation returns attributes about a file or directory given a path. This includes permissions, the number of entries (if the provided path points to a directory), timestamps of creation, timestamps of last access, and timestamps of last modification. However, as mentioned previously, \gls{FFS} does not implement all features, such as permissions. Instead of keeping track of a file's or directory's permissions, all calls to a valid path will return full read, write, and execute permissions for everyone. However, the timestamps are stored in the inode table of \gls{FFS}. The file or directory pointed to by the path does not need to be downloaded, all the metadata that \gls{FFS} stores is accessible through the inode entry in the inode table, and the inode table is always cached.

\subsubsection{fgetattr}
This operation is similar to \texttt{getattr} but is called from a user program context meaning that the file has a file handle associated with it. Other than skipping the path traverse step, this operation returns the equivalent information as \texttt{getattr}.

\subsubsection{statfs}
This operation returns metadata information about \gls{FFS}. This includes, among other things, the maximum filename size and the filesystem ID. The operation has a short computation time as it does not have to download or upload any files. The only variable information is read from the inode table which is stored in memory and thus does not have to be downloaded from the \gls{OWS}.

\subsubsection{access}
This operation, given a path returns whether or not the path can be accessed. As long as the path is valid, this always returns true.

\subsubsection{utimens}
This operation, provided new timestamps, updates the last access timestamp, the last modified timestamp, or both, of the file or directory at the given path. The file or directory does not have to be downloaded. However, the inode entry for the file's or directory's inode is updated with the new timestamps if they are newer than the previous timestamps but not greater than the current time since epoch. The new state of the inode table is updated to the \gls{OWS}, and the old version is removed from the \gls{OWS}.

\subsection{FFS limitations}
\label{subsec:ffs_limits}
\gls{FFS} has numerous limitations due to both implementation decisions and \gls{OWS} limits. As Flickr allows a \mbox{free-tier} user account to store up to 1\,000 images of up to \SI{200}{\mega\byte} per image, this allows storage of up to \SI{200}{\giga\byte} of images per account on Flickr. However, as the inode table is required to be stored on the filesystem, a maximum of 999 images can be used to save file and directory data. This limits the filesystem to a maximum of 999 files and directories when utilizing one \mbox{free-tier} account on Flickr, which also limits the maximum storage of file- and directory images to \SI{199.8}{\giga\byte}.

While Flicker supports each image to be up to \SI{200}{\mega\byte}, it is not possible to use the full \SI{200}{\mega\byte} to store the file or directory data. The image includes, among other things, a PNG header, other PNG attributes, and the \gls{CED} which in total is of greater size than the unencrypted data. To ensure that the \gls{PCD} along with the PNG header and other PNG attributes does not exceed the limit of \SI{200}{\mega\byte}, \gls{FFS} limits the \gls{PCD} size to allow at least \SI{10}{\mega\byte} for the PNG header and other PNG attributes, meaning that the \gls{PCD} can be a maximum of \SI{190}{\mega\byte}. The cryptographic variables \gls{IV}, salt, and the authentication tag are stored in the \gls{CED} using 12, 16, and 64 bytes respectively, for a total of 92 bytes. The size limit means that these 92 bytes, along with the encrypted cipher text, cannot exceed \SI{190}{\mega\byte}, meaning that the encrypted cipher text cannot exceed $190\,000\,000 - 92 = $\SI{189\,999\,908}{\byte}. However, as \gls{AES} is a block cipher producing cipher blocks of 16 bytes, the resulting cipher text must be divisible by 16. The largest encrypted cipher text that \gls{FFS} allows is therefore $floor(\frac{189\,999\,906}{16})*16 = 189\,999\,904$ bytes. Due to plain text padding, the unencrypted plain text can be a maximum of one byte less than this value\,\cite{z.z.coderAnswerSizeData2010}, meaning that the plain text can be a maximum of \SI{189\,999\,903}{\byte}. For simplicity, this is rounded down to \SI{189}{\mega\byte}, leaving almost \SI{11}{\mega\byte} in total for the PNG header and other PNG attributes. Therefore, \SI{189}{\mega\byte} is set as the maximum amount of data \gls{FFS} will store per image. Data greater than \SI{189}{\mega\byte} in size is split into multiple encoded images. For instance, a file of \SI{200}{\mega\byte} will be stored as \SI{189}{\mega\byte} in one image, and \SI{11}{\mega\byte} in another. 

\SI{189}{\mega\byte} of usable data per image gives \gls{FFS} a maximum storage capacity of \SI{188.811}{\giga\byte} using 999 files and directories on one \mbox{free-tier} account on Flickr. Each file with data requires at least one image, thus there can be a maximum of 998 \mbox{non-empty} files and directories in the filesystem, excluding the root directory. However, there could also be just one single entry of \SI{188.811}{\giga\byte} stored in the filesystem, which would have to represent the root directory.

The inode table keeps the information about empty files and directories even though they store no data on the \gls{OWS}. The inode of a file or directory is an unsigned \mbox{32-bit} integer, meaning that the inode table could theoretically store up to over four billion files and directories. However, due to the constraints mentioned above, most of these files and directories would have to be empty as Flickr limits the number of images stored. An empty file requires \SI{37}{\byte} in the inode table, consisting of the inode, length, and other variables that must exist for an inode entry. As the inode table is limited to one single image on the \gls{OWS}, the inode table is limited to a maximum size of \SI{189}{\mega\byte}. Further, the size of the inode table is \SI{4}{\byte} plus the size of each entry, and one of these entries is the root directory. Even if a file is empty, it is still stored with its filename and inode in its parent directory. A \mbox{non-empty} directory in the inode table requires approximately (depending on the post ID length generated by the \gls{OWS}) \SI{12}{\byte} per file or directory it contains. The maximum number of empty files and directories $X$ that the inode table can store is therefore, approximately:
$$
	X = ceil(\frac{189\,000\,000 - 4 - (12 * X)}{37}) + 1, X = 3\,857\,143
$$
The additional directory is the root directory. Thus, the maximum number of files and directories that the inode table can store is close to four million; however, this requires all files and directories, except the root directory, to be empty. These calculations are based on a single \mbox{free-tier} Flickr account. However, future work of \gls{FFS} could include multiple user accounts and multiple services. This could increase the limits on the filesystem.

Limits to the file sizes also depend on the machine where \gls{FFS} is mounted. When a file is read or written to, the complete file is read into memory. This requires the computer to provide at least as much memory as the size of the file. Further, the cache of \gls{FFS} can store up to 20 images with a size of \SI{5}{\mega\byte} in memory, requiring \SI{100}{\mega\byte} of memory. However, even if the computer has less memory available, more memory can often be provided through swap on the hard disk. Apple ensures that the swapped data is securely encrypted on the hard disk\,\cite{appleinc.WhatSecureVirtual}. However, using a swap puts a constraint on the available storage of the computer to be sufficient to store this data. Further, as \gls{FFS} temporarily saves the data on the local filesystem before it is uploaded to Flickr, the storage device must have sufficient storage available. For instance, a file larger than the available storage on the local filesystem cannot be saved to \gls{FFS}. If the local filesystem has no available storage, very few filesystem operations can be performed on \gls{FFS} as any operation that modifies the inode table requires the new inode table to be saved to the local filesystem before it is uploaded to Flickr. 

\gls{FFS} also stores data associated with file handles of modified and open files in memory. The amount of open files in \gls{FFS} is unbounded, and the amount of data \gls{FFS} can store per file handle is also unbounded. Further, the data associated with the file handle is not removed from memory until the file is closed. This presents a potential memory overflow scenario if, for instance, many files are opened and modified without being closed afterwards. 

Another limitation of \gls{FFS} is the rate limits presented by the Flickr \gls{API}. Flickr allows up to $3\,600$ \gls{API} requests per hour, after which the \gls{API} keys may be revoked by Flickr. $3\,600$ requests per hour equals $60$ requests per minute, or $1$ request per second. If the average request takes less than a second for constant, sequential Flickr \gls{API} calls, the \gls{API} keys could be revoked. Furthermore, some requests are sent concurrently to Flickr which means that \gls{FFS} could reach $3\,600$ \gls{API} calls faster. 


However, as long as \gls{FFS} is not constantly serving filesystem calls, the \gls{API} limit should be of little concern.

A limitation of \gls{FFS} that is not possible to quantify is the bandwidth and latency of the network connection from the user to Flickr. The connection can vary significantly depending on for instance the network load at a given moment and the geographic location of the user. A slow network connection is not something \gls{FFS} can solve, but is left as an exercise for the reader.

% TODO: 
%	Limitations to File handle, eg. collisions and how many fh's can be stored. Memory overflow?
%	Better network connection implicates easier to reach request limit
% 	"Can you quantify this? if thee are 4 \gls{API} calls for a file system operation such as read (as per Â§4.2.4) - this mean 15 such operations per minute. What are the implications of this for the depth of the directory tree?" for paragraph about \gls{API} limits
% 	How can you leave the impact of this simply up to your reader. What can you say about it? Since you are limited to one operation per second - for most of the operations other than read or write the network latency does not matter much and for most of your calls the is likely to be under 1 second. So given this, what can you say?

% TODO: ABOVE ABOVE