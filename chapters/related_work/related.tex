\section{Related filesystems}
\label{sec:rel_fs}
Many steganographic and deniable filesystems have been presented previously, but many of these are focused on filesystems for physical storage (such as disks) to which the user has access. For instance, Peters \etal created DEFY, a deniable filesystem using a \mbox{log-based} structure in 2014\,\cite{petersDEFYDeniableFile2014}. DEFY was built to be used exclusively on the \gls{SSD} found in mobile devices to provide a deniable filesystem that could be used in Android phones. Further examples of local \mbox{disk-based} filesystems can be found in \cite{andersonSteganographicFileSystem1998, mcdonaldStegFSSteganographicFile2000, domingo-ferrerSharedSteganographicFile2008, hanMultiuserSteganographicFile2010}. However, this thesis aims to create a filesystem that is not based on a physical disk but rather a \mbox{cloud-based} filesystem that uses images on o\glspl{OWS} as its storage medium. 

In 2007, \citeauthor{baliga2007web} presented the idea of a covert filesystem that hides the file data in images and uploads them to web services, named CovertFS\,\cite{baliga2007web}. Their paper lacks implementation of the filesystem, but they present an implementation plan which includes using \gls{FUSE}. They limit the filesystem such that each image posted will only store a maximum of \SI{4}{\kilo\byte} of steganographic file data, and the images posted on the web services will be actual images. This is unlike the idea underlying \gls{FFS} where the images are purely the encrypted file data with an image header; hence an image will simply look like random colored noise. An implementation of CovertFS has been attempted by \citeauthor{sosaSuperSecretFile2007}, which also used Tor to further anonymize the users\,\cite{sosaSuperSecretFile2007}.

In \citeyear{szczypiorskiStegHashNewMethod2016}, \citeauthor{szczypiorskiStegHashNewMethod2016} introduced the idea of StegHash - a way to hide steganographic data on \glspl{OSN} by connecting multimedia files, such as images and videos, with hashtags\,\cite{szczypiorskiStegHashNewMethod2016}. Specifically, images were posted to Twitter and Instagram along with certain permutations of hashtags that pointed to other posts through the use of a \mbox{custom-designed} secret transition generator. StegHash managed to store short messages with 10 bytes of hidden data with a 100\% success rate, while longer messages with up to 400 bytes of hidden data had a success rate of 80\%. \citeauthor{bieniaszSocialStegDiscApplicationSteganography2017} later presented SocialStegDisc, which was a filesystem application of the idea presented with StegHash\,\cite{bieniaszSocialStegDiscApplicationSteganography2017}. Multiple posts might be required to store a single file, and each post referenced the next post as a linked list; this means that you only need the root post to read all the data. This is unlike the idea of \gls{FFS} where a table will be kept to keep track of which posts store a certain file and in what order these posts should be concatenated, similar to an inode table. SocialStegDisc lacks an actual implementation of the filesystem but is similar to CovertFS and presents the idea of a social \mbox{media-based} filesystem.

TweetFS, created in 2011, is a filesystem created by Robert Winslow that stores its data on Twitter\,\cite{winslowTweetfsTweetfsMaster}. It was created as a proof of concept to show that it is possible to store file data on Twitter. The filesystem uses sequential text posts to store data. The filesystem is not mounted to the operating system; instead, the user interacts with a Python script through the command line. This makes the filesystem less convenient from a user's perspective compared to a mounted filesystem where the files can be browsed using a user interface or command line. There are two commands available in TweetFS: \texttt{upload} and \texttt{download}, which upload and download files or directories, respectively. Names and permissions of files and directories are maintained throughout the upload and download process. The tweets are not encrypted but are enciphered into English words which makes them look like nonsense paragraphs. This makes the filesystem less secure than an encrypted filesystem, as its contents can be read by anyone with access to the decoder. However, it does introduce a steganographic element to the filesystem.

In 2006, \citeauthor{jonesGoogleHackUse2006} created GmailFS - a mountable filesystem that uses Google's Gmail to store data\,\cite{jonesGoogleHackUse2006, jonesGmailFilesystemImplementation2006}. The filesystem was written in Python using \gls{FUSE} and was presented well before the introduction of Google Drive in 2012. GmailFS does not support encryption as the plain file data is stored in emails. Today, Gmail and Google Drive share their storage quota and GmailFS has since become redundant as Google Drive is an easier filesystem to use. GMail Drive is another example of a \mbox{Gmail-based} filesystem and it was influenced by GmailFS\,\cite{viksoeViksoeDkGMail2004}. GMail Drive has been declared dead by its author since 2015.

\gls{GCSF} is a filesystem that stores its data on Google Drive, built using \gls{FUSE}\,\cite{sergiudanGCSFVirtualFile2018,sergiudanHarababurelGcsf2021}. Google Drive provides a desktop application\,\cite{googleInstallSetGoogle} that presents a mounted volume in the local filesystem, representing the user's Google Drive filesystem. The mountable volume provided by the desktop application does not always immediately synchronize the stored data, but might instead store it locally until a later time. To enable direct synchronization of the data to Google Drive, \gls{GCSF} interacts with the Google Drive REST \gls{API} rather than the mounted filesystem volume. One benefit of always synchronizing the data with Google Drive is that the duration of a filesystem operation can be easily measured. For instance, a write operation on a file in \gls{GCSF} will not complete before the new file data has been completely stored on Google Drive. Therefore, the duration from the start of the filesystem operation until its end includes the time it takes to upload the file. In contrast, the duration of a filesystem operation on the mountable volume provided by the Google Drive Desktop application does not always include the time it takes to upload the file, as this upload can occur at a later time. One difference between \gls{GCSF} and the idea of \gls{FFS} is that \gls{GCSF} does not encrypt the data stored in the filesystem. While the data is, as mentioned previously, encrypted by Google Drive, the encryption keys are controlled by Google Drive, not the user of \gls{GCSF}. The data stored on \gls{GCSF} is stored as its original files in Google Drive, not as images as \gls{FFS} uses to store the data. The Google Drive filesystem architecture is utilized by \gls{GCSF}, for instance, by using its directory hierarchy structure. This allows \gls{GCSF} to avoid creating its own inode table and directory structures; as Google Drive provides this functionality, these structures similarly provide \gls{FFS} through the Google Drive \gls{API}. The development of \gls{GCSF} started in 2018\,\cite{sergiudanHarababurelGcsf2021}, and the repository in GitHub has around \num{2300} stars at the time of writing this thesis in March 2023. 

Another Google \mbox{Drive-based} filesystem is \mbox{google-drive-ocamlfuse}\,\cite{stradaGoogledriveocamlfuse2022}, developed for Linux using \gls{FUSE}. The project has been well received online. The repository has around \num{6700} stars on GitHub at the time of writing this thesis, and there are multiple articles online about the project\,\cite{guoanInstallGoogleDrive2021,sneddonMountYourGoogle2017,aminUseGoogleDrive2021}. The filesystem is well-developed and well-maintained. The filesystem supports filesystem operations such as symbolic links, Unix ownership, and multiple account support. According to the author of \gls{GCSF}, \gls{GCSF} tends to be faster than \mbox{google-drive-ocamlfuse} for certain operations, including reading cached files\,\cite{sergiudanShortGCSFTends2018,puscassergiudanShowHNGoogle2018}. \mbox{google-drive-ocamlfuse} has no native support for macOS as it is focused on Linux. 

\citeauthor{zadokCryptfsStackableVnode1998a} created Cryptfs, a stackable Vnode filesystem that encrypted the underlying, potentially unencrypted, filesystem\,\cite{zadokCryptfsStackableVnode1998a}. By making the filesystem stackable, any layer can be added on top of any other, and the abstraction occurs by each Vnode layer communicating with the one beneath. There is a potential to further stack additional layers using tools such as FiST\,\cite{zadokFiSTStackableFile}. This approach enables one to create not only an encrypted filesystem but also to provide redundancy by replicating data to different underlying filesystems. If these filesystems are independent, then this potentially increases availability and reliability. \gls{FFS} aims to achieve stackability through the use of \gls{FUSE}. 

% TODO: Mention CFS, eCryptfs, EncFS (part of EFST), Cepheus, CRUST, cryptoloop, etc.?
%	- Encrypted distributed filesystems, eg. eCryptfs widely used in linux
%
%	- Mention CryptFs on GCSF. What does FFS do instead?
%		- Uses unconventional storage 
%		- Explores the possibility to exploit this storage