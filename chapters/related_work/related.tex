\section{Related filesystems}
\label{sec:rel_fs}
% FIXME: Chip: "The discussion of other FUSE based filesystems seems really minimal."
Multiple steganographic filesystems have been presented previously but many of these are focused on filesystems for physical storage disks to that the user has access. For instance, Timothy Peters created DEFY, a deniable filesystem using a log-based structure in 2014\,\cite{petersDEFYDeniableFile2014}. DEFY was built to be used exclusively on Solid State Drives (\gls{SSD}) found in mobile devices to provide a steganographic filesystem that could be used on Android phones. Further examples of local disk-based filesystems can be found in \cite{andersonSteganographicFileSystem1998, mcdonaldStegFSSteganographicFile2000, domingo-ferrerSharedSteganographicFile2008, hanMultiuserSteganographicFile2010}, among other papers. However, this paper aims to create a filesystem that is not based on a physical disk but rather a cloud-based steganographic filesystem that uses online web services as its storage medium. 

In 2007, \citeauthor{baliga2007web} presented an idea of a covert filesystem that hides the file data in images and uploads them to web services, named CovertFS\,\cite{baliga2007web}. The paper lacks implementation of the filesystem but they present an implementation plan which includes using FUSE. They limit the filesystem such that each image posted will only store a maximum of \SI{4}{\kilo\byte} of steganographic file data and the images posted on the web services will be actual images. This is different from the idea of FFS where the images will be purely the encrypted file data and will therefore not be an image that represents anything but will instead look like random color noise. An implementation of CovertFS has been attempted by \citeauthor{sosaSuperSecretFile2007} which also used Tor to further anonymize the users\,\cite{sosaSuperSecretFile2007}.

In \citeyear{szczypiorskiStegHashNewMethod2016}, \citeauthor{szczypiorskiStegHashNewMethod2016} introduced the idea of StegHash - a way to hide steganographic data on Open Social Networks (\gls{OSN}) by connecting multimedia files, such as images and videos, with hashtags\,\cite{szczypiorskiStegHashNewMethod2016}. Specifically, images were posted to Twitter and Instagram along with certain permutations of hashtags that pointed to other posts through the use of a custom-designed secret transition generator. StegHash managed to store short messages with 10 bytes of hidden data with a 100\% success rate, while longer messages with up to 400 bytes of hidden data had a success rate of 80\%. \citeauthor{bieniaszSocialStegDiscApplicationSteganography2017} later presented SocialStegDisc which was a filesystem application of the idea presented with StegHash\,\cite{bieniaszSocialStegDiscApplicationSteganography2017}. Multiple posts could be required to store a single file and each post referenced the next post like a linked list, which means that you only need the root post to read all the data. This is unlike the idea of FFS where a table will be kept to keep track of which posts store a certain file, and in what order they should be concatenated, similar to the idea of an inode table. SocialStegDisc lacks actual implementation of the filesystem but similar to CovertFS presents the idea of a social media-based filesystem.

TweetFS is a filesystem created by Robert Winslow that stores the data on Twitter\,\cite{winslowTweetfsTweetfsMaster}, created in 2011. It was created as a proof of concept to show that it is possible to store file data on Twitter. The filesystem uses sequential text posts to store the data. The filesystem is not mounted to the operating system, instead, the user interacts with a Python script  through the command line. This makes the filesystem less convenient from a user perspective, compared to a mounted filesystem where the files can be browsed using a user interface or command line. There are two commands available: \texttt{upload} and \texttt{download} which upload and download files or directories, respectively. Names and permissions of files and directories are maintained throughout the upload and download process. The tweets are not encrypted but are enciphered into English words which makes them look like nonsense paragraphs, similar to what we mentioned in Section~\ref{sec:data_storage} about how arbitrary data can be encoded as plain text. This makes the filesystem less secure than an encrypted version as it can be read by anyone with access to the decoder. However, it does introduce a steganographic element to the filesystem.

In 2006, \citeauthor{jonesGoogleHackUse2006} created GmailFS - a mountable filesystem that uses Google's Gmail to store the data\,\cite{jonesGoogleHackUse2006, jonesGmailFilesystemImplementation2006}. The filesystem was written in Python using FUSE and was presented well before the introduction of Google Drive in 2012. It does not support encryption as the plain file data is stored in emails. Today, Gmail and Google Drive share their storage quota and GmailFS has since become redundant as Google Drive is an easier filesystem to use. GMail Drive is another example of a Gmail-based filesystem and it was influenced by GmailFS\,\cite{viksoeViksoeDkGMail2004}. GMail Drive has been declared dead by its author since 2015.

Google Conduce Sistem de Fi»ôiere (\gls{GCSF}) is a filesystem that stores its data on Google Drive, built using FUSE\,\cite{puscassergiudanGCSFVIRTUALFILE2018,puscasHarababurelGcsf2022}. On the other hand, Google Drive provides a desktop application\,\cite{googleInstallSetGoogle} that presents a mounted volume in the local filesystem, representing the user's Google Drive filesystem. The mountable volume provided by the desktop application does not always sync the stored data directly, but might instead store it locally until a later time. To enable direct synchronization of the data to Google Drive, GCSF interacts with the Google Drive REST API rather than the mounted filesystem volume. One benefit of always synchronizing the data with Google Drive is that the duration of a filesystem operation can be measured easily. For instance, a write operation on a file in GCSF will not complete before the new file data has been completely stored on Google Drive. Therefore, the duration from the start of the filesystem operation until its end includes the time it takes to upload the file. On the other hand, the duration of a filesystem operation on the mountable volume provided by the Google Drive Desktop application does not always include the time it takes to upload the file, this can occur at a later time. One difference between GCSF and the idea of FFS is that GCSF does not encrypt the data stored in the filesystem. While the data is, as mentioned previously, encrypted by Google Drive, the encryption keys are controlled by Google Drive, not the user of GCSF. The data stored on GCSF is also stored as its original files in Google Drive, not as images as FFS intends to store the data. The Google Drive filesystem architecture is utilized by GCSF, for instance by using its directory hierarchy structure. This allows GCSF to avoid creating its own inode table and directory structures, as Google Drive provides the functionality these structures similarly provide FFS, through the Google Drive API. The development of GCSF started in 2018\,\cite{puscasHarababurelGcsf2022}, and the repository in GitHub has around $2\,300$ starts as of writing. 

Another Google Drive-based filesystem is google-drive-ocamlfuse\,\cite{stradaGoogledriveocamlfuse2022}, developed for Linux using FUSE. The project is well received online. The repository has around $6\,700$ stars on GitHub at the time of writing and there are multiple articles online about the project\,\cite{guoanInstallGoogleDrive2021,sneddonMountYourGoogle2017,aminUseGoogleDrive2021}. The filesystem is well developed and, as of writing, well maintained. The filesystem supports filesystem operations such as symbolic links, Unix ownership, and multiple account support. According to the author of GCSF, GCSF tends to be faster than google-drive-ocamlfuse for certain operations, including reading cached files\,\cite{shubhamharnalShortGCSFTends2018,harababurelShowHNGoogle2018,}. google-drive-ocamlfuse has no native support of macOS but is focused on Linux. 

\citeauthor{zadokCryptfsStackableVnode1998} created Cryptfs, a stackable Vnode filesystem that encrypted the underlying, potentially unencrypted, filesystem\,\cite{zadokCryptfsStackableVnode1998}. By making the filesystem stackable, any layer can be added on top of any other, and the abstraction occurs by each Vnode layer communicating with the one beneath. There is a potential to further stack additional layers by using tools such as FiST\,\cite{FiSTStackableFile}. This approach enables one to create not only an encrypted filesystem but also to provide redundancy by replicating data to different underlying filesystems. If these filesystems are independent, then this potentially increases availability and reliability. FFS aims to achieve stackability through the use of FUSE. 
% FIXME: Chip: "While you mention CryptFS and FiST you do not say why you do not build your systems to use a stackable filesystem (as this would make adding redundancy much easier)"
% 	Stackable filesystem - kernel module between VFS and the actual filesystem (eg ext4)
%		According to "To fuse or not to fuse..." they build a stackable filesystem in FUSE
%			Maybe using the kernel API??
% 		Read 2.1 in this article, seems appropriate
